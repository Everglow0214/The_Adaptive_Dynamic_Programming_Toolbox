function [Phi_V, Costx, Costu0, alpha, beta, gamma] =...
    dataProc(data, N, stride, n, N1, m, N2, opt)
% >> This function generates necessary matrices that will
% be used in the iteration process.
%
% >> [Phi_V, gamma, beta, Costx, alpha, Costu0] =
%       dataProc(data, N, stride, n, N1, m, N2, opt)
% ======================== Input =========================
% data:   saved argumented states (with 1 or more
%         initial conditions)
% N:      number of data (a scalar or a vector) that are
%         generated by each initial state
%         If data is just the 1st output of the function
%         dataGeneModelBased, then N is just the 2nd
%         output of dataGeneModelBased. If data is
%         modified, then N should also be modified.
% stride: For example, suppose two trajectories are
%         generated as
%         [x11; x12; ...; x1a; x21; ...; x2b],
%         where x1~ indicates a value in the 1st
%         trajectory and x2~ indicates a value in the
%         2nd trajectory. The user may only use
%         x11, x13, x15, ...,
%         and
%         x21, x24, x27, ...,
%         by setting stride = [2; 3].
% n:      state dimension
% N1:     number of basis functions for the approximate
%         optimal cost function \hat{V}
% m:      control dimension
% N2:     number of basis functions for the approximate
%         optimal control \hat{u}
% opt:    type of basis functions
%         This parameter can be 'mono'.
% ========================================================
% ======================== Output ========================
% necessary matrices to be used in the iteration process
% ========================================================

Phi_V = [];
Costx = [];
Costu0 = [];
alpha = [];
beta = [];
gamma = [];

Num = N;
for i = 1:numel(N)
    idxTemp = 1:stride(i):N(i); % indices of data to be used 
    Num(i) = numel(idxTemp);
    
    idxNN = sum(N(1:i-1));
    dataTemp = zeros(Num(i),N1);
    switch opt
        case 'mono'
            for j = 1:Num(i)
                dataTemp(j,:) = mono_V(data(idxNN+idxTemp(j),1:n),N1);
            end
        otherwise
            fprintf('Please choose the type of basis');
            fprintf(' functions.\n');
            fprintf('The type can be\n');
            fprintf('''mono''.\n\n');
    end
    Phi_V = [Phi_V;
             dataTemp(2:Num(i),:) - dataTemp(1:Num(i)-1,:)];
    
    d = data(idxNN+idxTemp, n+1:end); % use only specific data
    d = d(2:Num(i),:) - d(1:Num(i)-1,:);

    Costx  = [Costx;
              d(:, 1)];
    Costu0 = [Costu0;
              d(:, 2)];
    alpha  = [alpha;
              d(:, 2+(1:m*N2))];
    beta   = [beta;
              d(:, 2+m*N2+(1:m*N2))];
    gamma  = [gamma;
              d(:, 3+2*m*N2:end)];
end
% Num = Num-1; % number of linear equaitions
end